import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { supabase } from "@/integrations/supabase/client";
import { useToast } from "@/hooks/use-toast";

export interface PurchaseOrderItem {
  id?: string;
  order_id?: string;
  product_id?: string | null;
  epi_id?: string | null;
  tipo: 'product' | 'epi';
  codigo?: string | null;
  descricao: string;
  unidade?: string;
  quantidade: number;
  valor_unitario: number;
  subtotal?: number;
}

export interface PurchaseOrder {
  id: string;
  numero: string;
  data_emissao: string;
  data_entrega?: string | null;
  supplier_id?: string | null;
  status: string;
  condicoes_pagamento?: string | null;
  frete?: string | null;
  observacoes?: string | null;
  total: number;
  solicitante?: string | null;
  aprovado_por?: string | null;
  data_aprovacao?: string | null;
  created_at: string;
  updated_at: string;
  created_by?: string | null;
  supplier?: {
    id: string;
    name: string;
    cnpj?: string | null;
    email?: string | null;
    phone?: string | null;
    address?: string | null;
  } | null;
  items?: PurchaseOrderItem[];
}

export interface CreatePurchaseOrderInput {
  data_emissao?: string;
  data_entrega?: string | null;
  supplier_id?: string | null;
  status?: string;
  condicoes_pagamento?: string;
  frete?: string;
  observacoes?: string | null;
  solicitante?: string | null;
  items: Omit<PurchaseOrderItem, 'id' | 'order_id' | 'subtotal'>[];
}

export function usePurchaseOrders() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  const {
    data: orders = [],
    isLoading,
    error,
    refetch,
  } = useQuery({
    queryKey: ["purchase-orders"],
    queryFn: async () => {
      const { data, error } = await supabase
        .from("purchase_orders")
        .select(`
          *,
          supplier:suppliers(id, name, cnpj, email, phone, address)
        `)
        .order("created_at", { ascending: false });

      if (error) throw error;
      return data as PurchaseOrder[];
    },
    staleTime: 5 * 60 * 1000,
  });

  const fetchOrderById = async (id: string): Promise<PurchaseOrder | null> => {
    const { data: order, error: orderError } = await supabase
      .from("purchase_orders")
      .select(`
        *,
        supplier:suppliers(id, name, cnpj, email, phone, address)
      `)
      .eq("id", id)
      .maybeSingle();

    if (orderError) throw orderError;
    if (!order) return null;

    const { data: items, error: itemsError } = await supabase
      .from("purchase_order_items")
      .select("*")
      .eq("order_id", id)
      .order("created_at", { ascending: true });

    if (itemsError) throw itemsError;

    return {
      ...order,
      items: items || [],
    } as PurchaseOrder;
  };

  const createOrder = useMutation({
    mutationFn: async (input: CreatePurchaseOrderInput) => {
      const { items, ...orderData } = input;

      // Create order (numero will be auto-generated by trigger)
      const { data: newOrder, error: orderError } = await supabase
        .from("purchase_orders")
        .insert({
          ...orderData,
          numero: '', // Will be auto-generated
        })
        .select()
        .single();

      if (orderError) throw orderError;

      // Insert items
      if (items.length > 0) {
        const itemsToInsert = items.map((item) => ({
          order_id: newOrder.id,
          product_id: item.product_id || null,
          epi_id: item.epi_id || null,
          tipo: item.tipo,
          codigo: item.codigo || null,
          descricao: item.descricao,
          unidade: item.unidade || 'UN',
          quantidade: item.quantidade,
          valor_unitario: item.valor_unitario,
        }));

        const { error: itemsError } = await supabase
          .from("purchase_order_items")
          .insert(itemsToInsert);

        if (itemsError) throw itemsError;
      }

      return newOrder;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["purchase-orders"] });
      toast({
        title: "Ordem de compra criada",
        description: "A ordem de compra foi criada com sucesso.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Erro ao criar ordem de compra",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const updateOrder = useMutation({
    mutationFn: async ({ id, ...data }: Partial<PurchaseOrder> & { id: string }) => {
      const { error } = await supabase
        .from("purchase_orders")
        .update({
          data_emissao: data.data_emissao,
          data_entrega: data.data_entrega,
          supplier_id: data.supplier_id,
          status: data.status,
          condicoes_pagamento: data.condicoes_pagamento,
          frete: data.frete,
          observacoes: data.observacoes,
          solicitante: data.solicitante,
          aprovado_por: data.aprovado_por,
          data_aprovacao: data.data_aprovacao,
          updated_at: new Date().toISOString(),
        })
        .eq("id", id);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["purchase-orders"] });
      toast({
        title: "Ordem de compra atualizada",
        description: "A ordem de compra foi atualizada com sucesso.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Erro ao atualizar ordem de compra",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const updateStatus = useMutation({
    mutationFn: async ({ id, status }: { id: string; status: string }) => {
      const updateData: Record<string, unknown> = {
        status,
        updated_at: new Date().toISOString(),
      };

      if (status === 'aprovada') {
        updateData.data_aprovacao = new Date().toISOString();
      }

      const { error } = await supabase
        .from("purchase_orders")
        .update(updateData)
        .eq("id", id);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["purchase-orders"] });
      toast({
        title: "Status atualizado",
        description: "O status da ordem foi atualizado com sucesso.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Erro ao atualizar status",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const deleteOrder = useMutation({
    mutationFn: async (id: string) => {
      const { error } = await supabase
        .from("purchase_orders")
        .delete()
        .eq("id", id);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["purchase-orders"] });
      toast({
        title: "Ordem de compra excluída",
        description: "A ordem de compra foi excluída com sucesso.",
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Erro ao excluir ordem de compra",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  const getStatistics = () => {
    const total = orders.length;
    const totalValue = orders.reduce((sum, o) => sum + Number(o.total || 0), 0);
    const byStatus = {
      rascunho: orders.filter((o) => o.status === 'rascunho').length,
      enviada: orders.filter((o) => o.status === 'enviada').length,
      confirmada: orders.filter((o) => o.status === 'confirmada').length,
      recebida: orders.filter((o) => o.status === 'recebida').length,
      cancelada: orders.filter((o) => o.status === 'cancelada').length,
    };

    return { total, totalValue, byStatus };
  };

  return {
    orders,
    isLoading,
    error,
    refetch,
    fetchOrderById,
    createOrder,
    updateOrder,
    updateStatus,
    deleteOrder,
    getStatistics,
  };
}
